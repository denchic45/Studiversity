import kotlin.collections.List;

CREATE TABLE eventEntity (
event_id TEXT NOT NULL UNIQUE PRIMARY KEY,
day_id TEXT NOT NULL,
position INTEGER AS Int NOT NULL,
room TEXT NOT NULL,
type TEXT NOT NULL,
event_name TEXT,
event_icon_name TEXT,
color TEXT,
subject_id TEXT,
teacher_ids TEXT AS List<String>,
group_id TEXT NOT NULL,
FOREIGN KEY (day_id) REFERENCES dayEntity(day_id) ON DELETE CASCADE
);


CREATE VIEW eventWithSubjectAndGroupAndTeachers AS
SELECT e.*, s.*, te.teacher_id, g.*, u.*
FROM eventEntity e
LEFT OUTER JOIN subjectEntity s ON s.subject_id = e.subject_id
LEFT OUTER JOIN teacherEventEntity te ON te.event_id = e.event_id
LEFT OUTER JOIN userEntity u ON u.user_id = te.teacher_id
JOIN studyGroupEntity g ON g.study_group_id == e.group_id;

upsert:
INSERT INTO eventEntity
VALUES ?
ON CONFLICT(event_id)
DO UPDATE SET
position = excluded.position;

getById:
SELECT * FROM eventEntity WHERE event_id =: id;

getDayByDateAndGroupId:
SELECT * FROM dayEntity
WHERE date =: date AND group_id =:groupId;

getEventsWithSubjectAndTeachersByDayId:
SELECT * FROM eventWithSubjectAndGroupAndTeachers e
WHERE day_id =: dayId ORDER BY position;

getEventsWithSubjectAndTeachersByDateAndTeacherId:
SELECT e.* FROM eventWithSubjectAndGroupAndTeachers e
JOIN dayEntity d ON d.day_id = e.day_id
WHERE d.date=:date AND e.teacher_id =: teacherId ORDER BY position;

deleteByGroupAndDateRange:
DELETE FROM dayEntity WHERE date
BETWEEN :start AND :end AND group_id =: groupId;

getEventIdsByDayId:
SELECT e.event_id FROM eventEntity e
WHERE day_id =: dayId;

deleteByEventId:
DELETE FROM eventEntity WHERE event_id =: eventId;